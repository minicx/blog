---
title: jvm01-JMM
date: 2019-03-12 17:37:57
tags: JVM
---

## 运行时数据区简介

{% asset_img jvm-1.png 运行时数据区 %}

首先看一张老图
jvm在运行时会把管理的内存进行划分,注意这些划分是逻辑上的划分,物理上还是原来的整体.这些区域有各自不同的用途,有各自不同的生命周期.

### 1.程序计数器
线程私有,跟随这线程的生命周期.相当于当前线程执行字节码的指针,在cpu上运行时会跟着这个指引选取下一个指令.

当线程在cpu上切换时,程序计数器会保存程序执行的位置.

存在另外的情况,如果在执行的是native方法,计数器的值为空,

### 2.JAVA虚拟机栈
线程私有,跟随这线程的生命周期.每个方法被执行的时候会创建一个栈帧(Stack Frame)原来存储局部变量变,操作栈.动态链接,方法出口等信息.一个方法的执行就是一个栈帧在虚拟机栈中入栈到出栈的过程.

虚拟机栈包含了局部变量表,局部变量表保存了基本数据类型,对象的指针等.

如果栈的深度过深,比如无限制的回归,循环体中申明了变量,都可能抛出StackOverflowError异常.如果栈动态扩展的话就可能触发常见的oom异常.

### 3.本地方法栈
本地方法栈是为native方法而生的,和java虚拟机栈的区别仅仅是语言上的区别.

### 4.Java堆

堆是jvm中内存最大的一部分.线程共享,jvm启动的时候开辟,用来存储对象实例,绝大多数的对象都在堆上面分配内存.只有少部分特列会在栈上分配内存(通过逃逸分析确定).
注意堆其实是逻辑上的内存空间,不是物理上连续的.如果new一个对象的时候,堆上没有足够的内存,而且堆也无法扩展后,就会抛出oom.

### 5.方法区

方法区也是线程共享的内存空间.主要作用是加载类信息,常量,静态变量,即使编译出的代码.这个区域的垃圾回收行为很少,主要就是常量池和类的卸载.

### 6.直接内存

在NIO中,channel和buffer可以通过native直接分配堆外内存,然后在java堆中存储该堆外的引用.如果java的-Xmx占用了绝大多数的服务器内存,那么分配堆外内存时可能会触发oom.
